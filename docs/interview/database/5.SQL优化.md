---
id: mysql-sql-optimize
slug: /mysql-sql-optimize
title: 5.SQL优化
authors: yuchengee
keywords: ['mysql', "sql"]
---

[Mysql高性能优化规范建议](https://www.cnblogs.com/huchong/p/10219318.html "Mysql高性能优化规范建议")


### SQL方面
1. 尽量控制单表数据量的大小，建议控制在500万以内  
500万并不是Mysql数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题  
可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小

2. 限制每张表上的索引数量，建议单张表索引不超过5个  
索引并不是越多越好！索引可以提高效率同样可以降低效率  
索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率  
因为mysql优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个
索引都可以用于查询，就会增加mysql优化器生成执行计划的时间，同样会降低查询性能 

3. 常见索引列建议
- 出现在SELECT、UPDATE、DELETE语句的WHERE从句中的列

- 包含在ORDER BY、GROUP BY、DISTINCT中的字段

- 并不要将符合1和2中的字段的列都建立一个索引， 通常将1、2中的字段建立联合索引效果更好

- 多表join的关联列

4. 对于频繁的查询优先考虑使用覆盖索引

覆盖索引：就是包含了所有查询字段(where,select,ordery by,group by包含的字段)的索引

覆盖索引的好处:  
- 避免Innodb表进行索引的二次查询  
Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息，
如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据
而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了IO操作，提升了查询效率

- 可以把随机IO变成顺序IO加快查询效率  
由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，
因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO

5. 禁止使用`SELECT *` 必须使用`SELECT <字段列表>` 查询  
:::note
消耗更多的CPU和IO以网络带宽资源  
无法使用覆盖索引  
可减少表结构变更带来的影响
:::

6. 禁止使用不含字段列表的INSERT语句
:::note
如： insert into values ('a','b','c');  
应使用 insert into t(c1,c2,c3) values ('a','b','c');
:::

7. 避免使用子查询，可以把子查询优化为join操作
:::note
通常子查询在in子句中，且子查询中为简单SQL(不包含union、group by、order by、limit从句)时, 才可以把子查询转化为关联查询进行优化。

子查询性能差的原因：  
 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响  

 特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大  

 由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询
:::

8. 避免使用JOIN关联太多的表
:::info
对于Mysql来说，是存在关联缓存的，缓存的大小可以由join_buffer_size参数进行设置  
在Mysql中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，
所占用的内存也就越大

如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，
就会影响到服务器数据库性能的稳定性

同时对于关联操作来说，会产生临时表操作，影响查询效率
Mysql最多允许关联61个表，**建议不超过5个**
:::

9. 对应同一列进行or判断时，使用in代替or
:::info
in 的值不要超过500个 

in 操作可以更有效的利用索引，or大多数情况下很少能利用到索引
:::

10. WHERE从句中禁止对列进行函数转换和计算
:::info
对列进行函数转换或计算时会导致无法使用索引

不推荐：  
where date(create_time)='20190101'  
推荐：  
where create_time >= '20190101' and create_time < '20190102'
:::

11. 在明显不会有重复值时使用UNION ALL 而不是UNION
:::info
UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作  
UNION ALL 不会再对结果集进行去重操作
:::

12. 拆分复杂的大 SQL 为多个小 SQL
- 大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL
- MySQL 中，一个 SQL 只能使用一个 CPU 进行计算
- SQL 拆分后可以通过并行执行来提高处理效率

### 数据库操作行为规范
超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作  
1. 大批量操作可能会造成严重的主从延迟  
主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，
而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况

2. binlog日志为row格式时会产生大量的日志  
大批量写操作会产生大量日志，特别是对于row格式二进制数据而言，由于在row格式中会记录每一行数据的修改，我们一次修改的数据越多，
产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因

3. 避免产生大事务操作  
大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对MySQL的性能产生非常大的影响
特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批